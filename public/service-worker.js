// src/service-worker.js
/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

clientsClaim();

// Precache all of the assets generated by your build process
precacheAndRoute([{"revision":"41e5dc7f930d6f320dc4709dbfc6a9e1","url":"public/index.html"},{"revision":"41e5dc7f930d6f320dc4709dbfc6a9e1","url":"public/offline.html"},{"revision":"17860cf82edbb7404030d8f9baaac4c2","url":"src/App.css"},{"revision":"a44a48f8feb43bb973690bd9792e868e","url":"src/App.js"},{"revision":"d18ac434afb00158b91831ac1e36c491","url":"src/App.test.js"},{"revision":"869e4764d2a49068ebe68b8d0bcd6a09","url":"src/components/JournalFeed.js"},{"revision":"cbe6c1f793ff6598aa7c296481b1700f","url":"src/components/Login.js"},{"revision":"48289154bbdcd1661773e15da0972af9","url":"src/components/Profile.js"},{"revision":"bba863e4322b1befe2e67980cfb028f7","url":"src/components/Register.js"},{"revision":"21a00f0fbf74fecc292e2ab6ebeed653","url":"src/components/ThemeSwitcher.js"},{"revision":"79c41e27e189017f3b5b0bb1c68721c7","url":"src/index.css"},{"revision":"11899aa49527705badace4d1999866ec","url":"src/index.js"},{"revision":"31ae43e4029f4850fbae5c5e551353cd","url":"src/ModernTheme.css"},{"revision":"240e2381f826a9bb84d178b29b7b9abe","url":"src/reportWebVitals.js"},{"revision":"495db0f7931f84ced230d34b2e8e7bcc","url":"src/serviceWorkerRegistration.js"},{"revision":"1a77571e1a8cf36018a41bcedf60db75","url":"src/setupTests.js"}]);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  ({ request, url }) => {
    if (request.mode !== 'navigate') {
      return false;
    }
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache the theme background images with a Cache First strategy
registerRoute(
  ({ url }) => {
    return [
      'marketplace.canva.com',
      'wallpaperaccess.com',
      'img.freepik.com'
    ].some(domain => url.href.includes(domain));
  },
  new CacheFirst({
    cacheName: 'theme-images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache Google Fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' ||
               url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache stylesheets and scripts
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Use Network First for your API calls to always try to get fresh data
registerRoute(
  ({ url }) => url.pathname.includes('/japp/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 1 day
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Optional: Add background sync for offline journal entries
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-new-entries') {
    event.waitUntil(syncNewEntries());
  }
});

// A function to sync journal entries that were created offline
async function syncNewEntries() {
  try {
    const entriesCache = await caches.open('offline-entries');
    const keys = await entriesCache.keys();
    
    await Promise.all(keys.map(async (request) => {
      try {
        // Attempt to fetch (which will now go through since we're online)
        const response = await fetch(request);
        if (response.ok) {
          // If successful, remove from offline cache
          await entriesCache.delete(request);
        }
      } catch (error) {
        console.error('Failed to sync entry:', error);
      }
    }));
  } catch (error) {
    console.error('Error during background sync:', error);
  }
}